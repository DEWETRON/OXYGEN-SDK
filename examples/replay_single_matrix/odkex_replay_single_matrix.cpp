// Copyright DEWETRON GmbH 2020

#include "odkapi_config_item_keys.h"
#include "odkfw_properties.h"
#include "odkfw_software_channel_plugin.h"
#include "odkbase_message_return_value_holder.h"
#include "odkapi_utils.h"

#include "sdk_csv_utils.h"

#include <cmath>
#include <cstdio>
#include <filesystem>
#include <fstream>
#include <string.h>

// Manifest constains necessary metadata for oxygen plugins
//   OxygenPlugin.name: unique plugin identifier; please use your (company) name to avoid name conflicts. This name is also used as a prefix in all custom config item keys.
//   OxygenPlugin.uuid: unique number (generated by a GUID/UUID generator tool) that stored in configuration files to match channels etc. to the correct plugin
static const char* PLUGIN_MANIFEST =
R"XML(<?xml version="1.0"?>
<OxygenPlugin name="ODK_REPLAY_SINGLE_MATRIX" version="1.0" uuid="102B673A-0F6B-457D-B1D4-19174865215B">
  <Info name="Example Plugin: Single matrix file replay">
    <Vendor name="DEWETRON GmbH"/>
    <Description>SDK Example plugin implementing file replay into a single value matrix channel.</Description>
  </Info>
  <Host minimum_version="3.7"/>
</OxygenPlugin>
)XML";

// A minimal translation file that maps the internal ConfigItem key to a nicer text for the user
static const char* TRANSLATION_EN =
R"XML(<?xml version="1.0"?>
<TS version="2.1" language="en" sourcelanguage="en">
    <context><name>ConfigKeys</name>
        <message><source>ODK_REPLAY_SINGLE_MATRIX/InputFile</source><translation>Input File</translation></message>
    </context>
</TS>
)XML";


// Keys for ConfigItems that are used to store channel settings

// Custom key (prefixed by plugin name) to store path to the input file
static const char* KEY_INPUT_FILE = "ODK_REPLAY_SINGLE_MATRIX/InputFile";

static const char* KEY_MATRIX_DESCRIPTION = "MatrixDescription";

using namespace odk::framework;

class ReplayChannel : public SoftwareChannelInstance
{
public:

    ReplayChannel()
        : m_input_file(new EditableStringProperty(""))
        , m_matrix_description(new EditableStringProperty(""))
        , m_rows(0)
        , m_cols(0)
        , m_next_tick(-1)
    {
        m_matrix_description->setVisiblity("HIDDEN");
    }

    // Describe how the software channel should be shown in the "Add Channel" dialog
    static odk::RegisterSoftwareChannel getSoftwareChannelInfo()
    {
        odk::RegisterSoftwareChannel telegram;
        telegram.m_display_name = "Example Plugin: Single matrix file replay";
        telegram.m_service_name = "CreateChannel";
        telegram.m_display_group = "Data Input";
        telegram.m_description = "Adds a single matrix/vector channel that delivers data read from a CSV file";
        telegram.m_analysis_capable = false;
        return telegram;
    }

    void updatePropertyTypes(const PluginChannelPtr& output_channel) override
    {
    }

    void updateStaticPropertyConstraints(const PluginChannelPtr& channel) override
    {
    }

    bool update() override
    {
        // channel is only valid if we can properly parse the specified csv file
        // in production code the parsing should not be done on every config change, but only if the filename was updated
        const auto filename = std::filesystem::path(m_input_file->getValue());

        CSVNumberReader csv;
        std::ifstream input_stream(filename.native());

        m_next_tick = -1;
        m_values.clear();

        double range_min = std::numeric_limits<double>::max();
        double range_max = std::numeric_limits<double>::lowest();

        m_rows = 0;
        m_cols = 0;

        if (input_stream && csv.parse(input_stream) && !csv.m_values.empty())
        {
            m_rows = csv.m_values.size();
            m_cols = 0;
            // determine number of columns
            for (const auto& row_values : csv.m_values)
            {
                m_cols = std::max(m_cols, row_values.size());
            }

            m_values.reserve(m_rows * m_cols);
            for (const auto& row_values : csv.m_values)
            {
                for (std::size_t column = 0; column < m_cols; ++column)
                {
                    if (row_values.size() > column && !std::isnan(row_values[column]))
                    {
                        range_min = std::min(range_min, row_values[column]);
                        range_max = std::max(range_max, row_values[column]);
                        m_values.push_back(row_values[column]);
                    }
                    else
                    {
                        m_values.push_back(std::numeric_limits<double>::quiet_NaN());
                    }
                }
            }
        }

        bool is_valid = range_min <= range_max && !m_values.empty();

        getRootChannel()->setRange({range_min, range_max, "", ""});
        getRootChannel()->setValid(is_valid);
        getRootChannel()->getRangeProperty()->setLive(is_valid);
        getRootChannel()->setSimpleTimebase(m_sample_rate->getValue().m_val);
        getRootChannel()->setSampleFormat(
            odk::ChannelDataformat::SampleOccurrence::SINGLE_VALUE,
            odk::ChannelDataformat::SampleFormat::DOUBLE,
            static_cast<uint32_t>(m_rows * m_cols));


        if (is_valid)
        {
            std::string description;
            if (m_rows > 1)
            {
                const char* const xml_matrix_description_2d =
                    R"xxx(<?xml version='1.0' encoding='UTF-8'?>
                            <MatrixDescription version="1">
                                <Dimensions>
                                    <Dimension size="%u" name="X">
                                         <LinearAxis min="0" max="%u" unit=""/>
                                    </Dimension>
                                    <Dimension size="%u" name="Y">
                                         <LinearAxis min="0" max="%u" unit=""/>
                                    </Dimension>
                                </Dimensions>
                            </MatrixDescription>
                            )xxx";
                char buffer[1024];
                int count = snprintf(buffer, sizeof(buffer), xml_matrix_description_2d,
                    static_cast<uint32_t>(m_cols), static_cast<uint32_t>(m_cols - 1),
                    static_cast<uint32_t>(m_rows), static_cast<uint32_t>(m_rows - 1));
                description.assign(buffer, count);
            }
            else
            {
                const char* const xml_matrix_description_1d =
                    R"xxx(<?xml version='1.0' encoding='UTF-8'?>
                            <MatrixDescription version="1">
                                <Dimensions>
                                    <Dimension size="%u" name="X">
                                         <LinearAxis min="0" max="%u" unit=""/>
                                    </Dimension>
                                </Dimensions>
                            </MatrixDescription>
                            )xxx";
                char buffer[1024];
                int count = snprintf(buffer, sizeof(buffer), xml_matrix_description_1d,
                    static_cast<uint32_t>(m_cols), static_cast<uint32_t>(m_cols - 1));
                description.assign(buffer, count);
            }
            m_matrix_description->setValue(description);
        }
        else
        {
            m_matrix_description->setValue({});
        }

        return is_valid;
    }

    void create(odk::IfHost* host) override
    {
        getRootChannel()->setSamplerate({1.0, "Hz"});
        m_sample_rate = getRootChannel()->getSamplerateProperty();
        //SampleRate can be configured freely in a wide range (0.01 to 1000 Hz)
        m_sample_rate->setMinMaxConstraint(0.01, 1000.0);

        getRootChannel()->setDefaultName("Replay channel")
            .setSampleFormat(
                odk::ChannelDataformat::SampleOccurrence::SINGLE_VALUE,
                odk::ChannelDataformat::SampleFormat::DOUBLE,
                1)
            .setSimpleTimebase(m_sample_rate->getValue().m_val)
            .setDeletable(true)
            .addProperty(KEY_INPUT_FILE, m_input_file)
            .addProperty(KEY_MATRIX_DESCRIPTION, m_matrix_description);
    }

    bool configure(
        const odk::UpdateChannelsTelegram& request,
        std::map<std::uint32_t, std::uint32_t>& channel_id_map) override
    {
        configureFromTelegram(request, channel_id_map);
        return true;
    }

    void prepareProcessing(odk::IfHost* host) override
    {
        const auto ts = getMasterTimestamp(host);
        const auto rate_factor = m_sample_rate->getValue().m_val / ts.m_frequency;
        m_next_tick = static_cast<std::uint64_t>(ts.m_ticks* rate_factor);
    }

    void process(ProcessingContext& context, odk::IfHost *host) override
    {
        std::uint32_t channel_id = getRootChannel()->getLocalId();
        auto ts = getMasterTimestamp(host);

        auto tick = m_next_tick;
        const auto rate_factor = m_sample_rate->getValue().m_val / ts.m_frequency;
        std::uint64_t target_tick = static_cast<std::uint64_t>(ts.m_ticks * rate_factor);
#if 0
        while (tick < target_tick)
        {
            addSamples(host, channel_id, tick, m_values.data(), sizeof(double) * m_values.size());
            tick += rate_factor; // TODO: is this correct?
        }
#else
        // The simplest way is to emit a single sample each time we are called, the value is constant anyway
        addSample(host, channel_id, target_tick, m_values.data(), sizeof(double) * m_values.size());
        m_next_tick = target_tick;
#endif
    }

private:
    std::shared_ptr<EditableStringProperty> m_input_file;
    std::shared_ptr<EditableScalarProperty> m_sample_rate;
    std::shared_ptr<EditableStringProperty> m_matrix_description;
    std::vector<double> m_values;
    std::size_t m_rows;
    std::size_t m_cols;

    std::uint64_t m_next_tick; // timestamp of the next sample that will be generated in doProcess()
};

class ReplaySingleMatrixPlugin : public SoftwareChannelPlugin<ReplayChannel>
{
public:
    void registerTranslations() final
    {
        addTranslation(TRANSLATION_EN);
    }
};

OXY_REGISTER_PLUGIN1("ODK_REPLAY_SINGLE_MATRIX", PLUGIN_MANIFEST, ReplaySingleMatrixPlugin);
