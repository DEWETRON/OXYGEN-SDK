// Copyright DEWETRON GmbH 2019

#ifdef _WIN32
#define  _SILENCE_ALL_CXX17_DEPRECATION_WARNINGS
#endif

#include "odkfw_properties.h"
#include "odkfw_software_channel_plugin.h"
#include "odkbase_message_return_value_holder.h"
#include "odkapi_logging.h"
#include "odkapi_utils.h"
#include "odkuni_assert.h"
#include "sdk_csv_utils.h"

#include <codecvt>
#include <filesystem>
#include <fstream>
#include <string.h>

// Manifest constains necessary metadata for oxygen plugins
//   OxygenPlugin.name: unique plugin identifier; please use your (company) name to avoid name conflicts. This name is also used as a prefix in all custom config item keys.
//   OxygenPlugin.uuid: unique number (generated by a GUID/UUID generator tool) that stored in configuration files to match channels etc. to the correct plugin
static const char* PLUGIN_MANIFEST =
R"XML(<?xml version="1.0"?>
<OxygenPlugin name="ODK_REPLAY_MESSAGE" version="1.0" uuid="A7308ACF-EA6D-4028-AAF3-35F8104837FA">
  <Info name="Example Plugin: Simple message file replay">
    <Vendor name="DEWETRON GmbH"/>
    <Description>SDK Example plugin implementing file replay into a message channel.</Description>
  </Info>
  <Host minimum_version="3.7"/>
</OxygenPlugin>
)XML";

// A minimal translation file that maps the internal ConfigItem key to a nicer text for the user
static const char* TRANSLATION_EN =
R"XML(<?xml version="1.0"?>
<TS version="2.1" language="en" sourcelanguage="en">
    <context><name>ConfigKeys</name>
        <message><source>ODK_REPLAY_MESSAGE/InputFile</source><translation>Input File</translation></message>
        <message><source>ODK_REPLAY_MESSAGE/ChannelType</source><translation>Channel Type</translation></message>
    </context>
    <context><name>ConfigValues</name>
        <message><source>ODK_REPLAY_MESSAGE/SelectInputFile</source><translation>Select Input File</translation></message>
    </context>
</TS>
)XML";

// Keys for ConfigItems that are used to store channel settings

// Custom key (prefixed by plugin name) to store path to the input file
static const char* KEY_INPUT_FILE = "ODK_REPLAY_MESSAGE/InputFile";
static const char* KEY_CHANNEL_TYPE = "ODK_REPLAY_MESSAGE/ChannelType";
static const char* KEY_NEON_CHANNEL_TYPE = "ChannelType";

static const char* SELECT_INPUT_FILE = "ODK_REPLAY_MESSAGE/SelectInputFile";

std::map<std::string,
                //Format                            Dimension
    std::pair<odk::ChannelDataformat::SampleFormat, std::uint32_t>> SupportedTypes
{
    {"ARINC_429",   std::make_pair<>(odk::ChannelDataformat::SampleFormat::BYTE, 4u)},
    {"MILSTD_1553", std::make_pair<>(odk::ChannelDataformat::SampleFormat::BYTE, 74u)},
    {"CAN",         std::make_pair<>(odk::ChannelDataformat::SampleFormat::CAN_MESSAGE, 0u)},
    {"FLEXRAY",     std::make_pair<>(odk::ChannelDataformat::SampleFormat::FLEXRAY_MESSAGE, 0u)}
};

static const double TIMEBASE_FREQUENCY = 1000000.0;

using namespace odk::framework;

using FileType = EditableFilePathProperty::FileType;

namespace
{
    std::wstring toWString(const std::string& utf8s)
    {
        std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t> wstring_converter;
        return wstring_converter.from_bytes(utf8s);
    }
}

class ReplayMessageChannel : public SoftwareChannelInstance
{
public:

    ReplayMessageChannel()
        : m_input_file(new EditableFilePathProperty(FileType::INPUT_FILE, "", SELECT_INPUT_FILE, "", { "Supported Files (*.csv)" }))
        , m_channel_type(new SelectableProperty(odk::Property{ KEY_CHANNEL_TYPE, "ARINC_429", "DAQChannelType"} ))
        , m_neon_channel_type(new SelectableProperty(odk::Property{ KEY_CHANNEL_TYPE, "ARINC_429", "DAQChannelType" }))
        , m_file_duration(0)
        , m_next_tick(std::numeric_limits<uint64_t>::max())
    {
        for (auto stype : SupportedTypes)
        {
            m_channel_type->addOption(odk::Property{ KEY_CHANNEL_TYPE, stype.first, "DAQChannelType" });
        }
    }

    // Describe how the software channel should be shown in the "Add Channel" dialog
    static odk::RegisterSoftwareChannel getSoftwareChannelInfo()
    {
        odk::RegisterSoftwareChannel telegram;
        telegram.m_display_name = "Example Plugin: Simple message file replay";
        telegram.m_service_name = "CreateChannel";
        telegram.m_display_group = "Data Input";
        telegram.m_description = "Adds an message channel that delivers samples read from a CSV file.";
        telegram.m_analysis_capable = false;
        return telegram;
    }

    void updatePropertyTypes(const PluginChannelPtr& output_channel) override
    {
        ODK_UNUSED(output_channel);
    }

    void updateStaticPropertyConstraints(const PluginChannelPtr& channel) override
    {
        ODK_UNUSED(channel);
    }

    bool update() override
    {
        // channel is only valid if we can properly parse the specified csv file
        // in production code the parsing should not be done on every config change, but only if the filename was updated
        CSVMessageReader csv;
        const auto filename =
            std::filesystem::path(toWString(m_input_file->getFilename()));
        std::ifstream input_stream(filename.native());

        m_next_tick = std::numeric_limits<uint64_t>::max();
        m_values.clear();

        m_neon_channel_type->setValue(m_channel_type->getValue());

        auto is_valid = false;
        const auto stype = m_channel_type->getValue().getStringValue();

        size_t max_value_size = 0;
        if (SupportedTypes.count(stype))
        {
            getRootChannel()->setSampleFormat(
                odk::ChannelDataformat::SampleOccurrence::ASYNC,
                SupportedTypes[stype].first,
                SupportedTypes[stype].second);
            is_valid = true;
            //real size would have to consider the data type,
            //but the numeric value is the same for our usage.
            //(non-byte samples can be of any size (=0))
            max_value_size = SupportedTypes[stype].second;
        }

        try
        {
            m_file_duration = 0;
            if (input_stream && csv.parse(input_stream) && !csv.m_values.empty())
            {
                for (auto& entry : csv.m_values)
                {
                    uint64_t time = static_cast<uint64_t>(entry.m_time * TIMEBASE_FREQUENCY);
                    m_file_duration = std::max(m_file_duration, time + 1);
                    if (max_value_size && entry.m_message.size() > max_value_size)
                    {
                        entry.m_message.resize(max_value_size);
                    }
                    m_values[time] = entry.m_message;
                }
            }
            is_valid &= m_file_duration > 0;
        }
        catch (...)
        {
            auto log_msg = getHost()->createValue<odk::IfStringValue>();
            log_msg->set(std::string("parsing error in file ')" + m_input_file->getFilename() + "'").c_str());
            ODK_VERIFY(getHost()->messageAsync(odk::host_msg_async::LOG_MESSAGE, odk::LOGLEVEL_ERROR, log_msg.get()) == 0);

            m_file_duration = 0;
        };

        getRootChannel()->setValid(is_valid);
        getRootChannel()->setSimpleTimebase(TIMEBASE_FREQUENCY);

        return is_valid;
    }

    void create(odk::IfHost* host) override
    {
        ODK_UNUSED(host);

        getRootChannel()->setDefaultName("Replay channel")
            .setSampleFormat(
                odk::ChannelDataformat::SampleOccurrence::ASYNC,
                odk::ChannelDataformat::SampleFormat::CAN_MESSAGE,
                1)
            .setSimpleTimebase(TIMEBASE_FREQUENCY)
            .setDeletable(true)
            .addProperty(KEY_INPUT_FILE, m_input_file)
            .addProperty(KEY_CHANNEL_TYPE, m_channel_type)
            .addProperty(KEY_NEON_CHANNEL_TYPE, m_neon_channel_type);
    }

    bool configure(
        const odk::UpdateChannelsTelegram& request,
        std::map<std::uint32_t, std::uint32_t>& channel_id_map) override
    {
        if(odk::isAnalysisModeActive(getHost()))
        {
            return false;
        }

        configureFromTelegram(request, channel_id_map);
        if (getHost())
        {
            auto setup_path_str = getHost()->getValue<odk::IfStringValue>(odk::queries::OxygenPaths, odk::queries::OxygenPaths_SetupDir);
            if (setup_path_str)
            {
                m_input_file->setDefaultPath(setup_path_str->getValue());
            }
        }
        return true;
    }

    void prepareProcessing(odk::IfHost* host) override
    {
        const auto ts = getMasterTimestamp(host);
        const auto rate_factor = TIMEBASE_FREQUENCY / ts.m_frequency;
        m_next_tick = static_cast<std::uint64_t>(ts.m_ticks* rate_factor);
    }

    void process(ProcessingContext& context, odk::IfHost *host) override
    {
        ODK_UNUSED(context);

        if (m_file_duration == 0)
        {
            return;
        }
        std::uint32_t channel_id = getRootChannel()->getLocalId();
        auto ts = getMasterTimestamp(host);
        const auto rate_factor = TIMEBASE_FREQUENCY / ts.m_frequency;

        auto tick = m_next_tick;
        std::uint64_t target_tick = static_cast<std::uint64_t>(ts.m_ticks * rate_factor);
        while (tick < target_tick)
        {
            const auto rel_base = tick / m_file_duration;
            const auto rel_tick = tick % m_file_duration;
            const auto value_it = rel_tick == 0 ? m_values.begin() : m_values.upper_bound(rel_tick - 1);

            if (value_it == m_values.end())
            {
                tick = std::min(target_tick, (rel_base + 1) * m_file_duration);
            }
            else
            {
                tick = rel_base * m_file_duration + value_it->first;
                addSample(host, channel_id, tick, value_it->second.data(), value_it->second.size());
                ++tick;
            }
        }
        m_next_tick = tick;
    }

private:
    std::shared_ptr<EditableFilePathProperty> m_input_file;
    std::shared_ptr<SelectableProperty> m_channel_type;
    std::shared_ptr<SelectableProperty> m_neon_channel_type;
    std::map<uint64_t, std::vector<uint8_t>> m_values;
    uint64_t m_file_duration;

    std::uint64_t m_next_tick; // timestamp of the next sample that will be generated in doProcess()
};

class ReplayMessagePlugin : public SoftwareChannelPlugin<ReplayMessageChannel>
{
public:
    void registerTranslations() final
    {
        addTranslation(TRANSLATION_EN);
    }
};

OXY_REGISTER_PLUGIN1("ODK_REPLAY_MESSAGE", PLUGIN_MANIFEST, ReplayMessagePlugin);

