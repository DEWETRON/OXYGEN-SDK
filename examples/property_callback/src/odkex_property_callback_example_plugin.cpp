// Copyright DEWETRON GmbH 2022

#include "odkapi_oxygen_queries.h"
#include "odkapi_error_codes.h"
#include "odkbase_api_object_ptr.h"
#include "odkfw_custom_request_handler.h"
#include "odkfw_software_channel_plugin.h"

// Manifest constains necessary metadata for oxygen plugins
//   OxygenPlugin.name: unique plugin identifier; please use your (company) name to avoid name conflicts. This name is also used as a prefix in all custom config item keys.
//   OxygenPlugin.uuid: unique number (generated by a GUID/UUID generator tool) that stored in configuration files to match channels etc. to the correct plugin
static const char* PLUGIN_MANIFEST =
R"XML(<?xml version="1.0"?>
<OxygenPlugin name="ODK_PROPERTY_CALLBACK_EXAMPLE_PLUGIN" version="1.0" uuid="5BF1FA99-06CA-4FFC-A0F5-E4390DCDC6D8" group="OFFICIAL">
  <Info name="Example Plugin: Property Callback">
    <Vendor name="Dewetron"/>
    <Description>Example to demonstrate property callbacks</Description>
  </Info>
  <Host minimum_version="5.3"/>
  <UsesUIExtensions/>
</OxygenPlugin>
)XML";

// A minimal translation file that maps the internal ConfigItem key to a nicer text for the user
static const char* TRANSLATION_EN =
R"XML(<?xml version="1.0"?>
<TS version="2.1" language="en" sourcelanguage="en">
    <context><name>ConfigKeys</name>
        <message><source>ODK_CALLBACK_EXAMPLE/InputChannel</source><translation>Input Channel</translation></message>
        <message><source>ODK_CALLBACK_EXAMPLE/DebugText</source><translation>Debug Text</translation></message>
        <message><source>ODK_CALLBACK_EXAMPLE/InputChannelName</source><translation>Input Channel Name</translation></message>
    </context>
</TS>
)XML";

// Keys (prefixed by plugin name) for ConfigItems that are used to store channel settings
static const char* KEY_INPUT_CHANNEL = "ODK_CALLBACK_EXAMPLE/InputChannel";
static const char* KEY_DEBUG_TEXT = "ODK_CALLBACK_EXAMPLE/DebugText";
static const char* KEY_INPUT_CHANNEL_NAME = "ODK_CALLBACK_EXAMPLE/InputChannelName";

// Internal used Key
static const char* NAME_OUTPUT_CHANNEL_1 = "Channel 1";
static const char* NAME_OUTPUT_CHANNEL_2 = "Channel 2";

using namespace odk::framework;

class CallbackExampleChannel;

namespace
{
    template<class PropertyClass, class ValueClass>
    std::shared_ptr<PropertyClass> updateProperty(
        PluginChannelPtr& channel, const std::string& name,
        const ValueClass& value, bool active = true)
    {
        auto raw_property = channel->getProperty(name);
        auto property = std::dynamic_pointer_cast<PropertyClass>(raw_property);
        if (property)
        {
            property->setValue(value);
            property->setLive(active);
        }
        else
        {
            property = std::make_shared<PropertyClass>(value);
            channel->addProperty(name, property);
            property->setLive(active);
        }
        return property;
    }

    template<class PROPERTY_TYPE>
    auto getPropertyValue(const PluginChannelPtr channel, const std::string& key)
        -> decltype(std::declval<PROPERTY_TYPE>().getValue())
    {
        if (channel)
        {
            const auto prop = std::dynamic_pointer_cast<PROPERTY_TYPE>(channel->getProperty(key));
            if (prop)
            {
                return prop->getValue();
            }
        }

        return {};
    }
}

class EditableChannelIDPropertyWithCallback : public EditableChannelIDProperty
{
public:
    explicit EditableChannelIDPropertyWithCallback(const RawPropertyHolder& value)
        : m_enable_callback(false)
        , m_local_id{}
        , m_parent{}

    {
        if (value.getProperty().isValid())
        {
            update(value.getProperty());
        }
    }

    explicit EditableChannelIDPropertyWithCallback(int local_id, CallbackExampleChannel* parent)
        : m_enable_callback(false)
        , m_local_id(local_id)
        , m_parent(parent)
    {}

    void enableCallback()
    {
        m_enable_callback = true;
    }

    void setLocalChannelId(uint32_t id)
    {
        m_local_id = id;
    }

    void setParent(CallbackExampleChannel* parent)
    {
        m_parent = parent;
    }

    bool update(const odk::Property& value) override;

private:
    bool m_enable_callback;
    uint32_t m_local_id;
    CallbackExampleChannel* m_parent;
};

class CallbackExampleChannel : public SoftwareChannelInstance
{
public:
    CallbackExampleChannel()
    {
    }

    // Describe how the software channel should be shown in the "Add Channel" dialog
    static odk::RegisterSoftwareChannel getSoftwareChannelInfo()
    {
        odk::RegisterSoftwareChannel telegram;
        telegram.m_display_name = "Example Plugin: Property Callback";
        telegram.m_service_name = "CreateChannel";
        telegram.m_display_group = "Simple Examples";
        telegram.m_description = "Demonstrate Callback mechanism for properties.";
        telegram.m_analysis_capable = false;
        return telegram;
    }

    InitResult init(const InitParams&) override
    {
        return { true };
    }

    void loadFinished() override
    {
        for (auto& an_output_channel : m_output_channels)
        {
            auto prop = std::dynamic_pointer_cast<EditableChannelIDPropertyWithCallback>
                (an_output_channel->getProperty(KEY_INPUT_CHANNEL));

            if (prop)
            {
                prop->setParent(this);
                prop->setLocalChannelId(an_output_channel->getLocalId());
                prop->enableCallback();
            }
        }
    }

    void createChannelIfNeeded(const char* const key)
    {
        if (!getOutputChannelByKey(key))
        {
            auto output_channel = addOutputChannel(key, nullptr);
            output_channel->addProperty(KEY_DEBUG_TEXT,
                std::make_shared<EditableStringProperty>(std::string(key) + " has no input channel"));
            output_channel->addProperty(KEY_INPUT_CHANNEL_NAME,
                std::make_shared<EditableStringProperty>(""));
            output_channel->setDefaultName(key)
                .setSampleFormat(
                    odk::ChannelDataformat::SampleOccurrence::SYNC,
                    odk::ChannelDataformat::SampleFormat::FLOAT,
                    1)
                .setDeletable(true)
                ;

            auto input_chn_prop = std::make_shared<EditableChannelIDPropertyWithCallback>(output_channel->getLocalId(), this);
            input_chn_prop->enableCallback();
            output_channel->addProperty(KEY_INPUT_CHANNEL, input_chn_prop);
        }
    }

    bool update() override
    {
        createChannelIfNeeded(NAME_OUTPUT_CHANNEL_1);
        createChannelIfNeeded(NAME_OUTPUT_CHANNEL_2);

        for (const auto a_changed_channel : m_channels_changed)
        {
            auto output_channel = getOutputChannel(a_changed_channel);
            const auto new_input_id =
                getPropertyValue<EditableChannelIDPropertyWithCallback>(
                    output_channel, KEY_INPUT_CHANNEL);
            const auto input_channel_proxy = getInputChannelProxy(new_input_id);

            const auto input_channel_name = input_channel_proxy ?
                input_channel_proxy->getName() : std::string();

            updateProperty<EditableStringProperty>(
                output_channel, KEY_INPUT_CHANNEL_NAME, input_channel_name);
        }
        m_channels_changed.clear();

        return true;
    }

    void create(odk::IfHost*) override
    {
        getRootChannel()->setDefaultName("Callback Instance channel")
            .setDeletable(true);
    }


    bool configure(
        const odk::UpdateChannelsTelegram& request,
        std::map<std::uint32_t, std::uint32_t>& channel_id_map) override
    {
        configureFromTelegram(request, channel_id_map);

        return true;
    }

    void updatePropertyTypes(const PluginChannelPtr& output_channel) override
    {
        replacePropertyType<EditableChannelIDPropertyWithCallback>(output_channel, KEY_INPUT_CHANNEL);
        replacePropertyType<EditableStringProperty>(output_channel, KEY_DEBUG_TEXT);
        replacePropertyType<EditableStringProperty>(output_channel, KEY_INPUT_CHANNEL_NAME);
    }

    void updateStaticPropertyConstraints(const PluginChannelPtr& channel) override
    {
        channel->setDeletable(true);
    }

    void markInputChannelChange(std::uint32_t local_channel_id)
    {
        m_channels_changed.insert(local_channel_id);
    }

    void initTimebases(odk::IfHost*) override
    {
        if (getInputChannelProxies().size() > 0)
        {
            auto input_channel = *getInputChannelProxies().begin();

            if (input_channel)
            {

                auto tb_frequency = input_channel->getTimeBase().m_frequency;

                auto all_output_channels = getOutputChannels();
                for (auto& ch : all_output_channels)
                {
                    ch->setSimpleTimebase(tb_frequency);
                }
            }
        }
    }

    void prepareProcessing(odk::IfHost*) override
    {
    }

    uint64_t getTickAtOrAfter(double time, double frequency)
    {
        if (time == 0.0)
        {
            return 0;
        }
        return static_cast<uint64_t>(std::nextafter(std::nextafter(time, 0.0) * frequency, std::numeric_limits<double>::lowest())) + 1;
    }


    void process(ProcessingContext&, odk::IfHost*) override
    {
    }

private:
    std::set<std::uint32_t> m_channels_changed;

};

class CallbackExamplePlugin : public SoftwareChannelPlugin<CallbackExampleChannel>
{
public:

    CallbackExamplePlugin()
    {
    }

    bool validateInputChannels(const std::vector<InputChannel::InputChannelData>&, std::vector<std::uint64_t>&) final
    {
        return true;
    }

    void registerResources() final
    {
        addTranslation(TRANSLATION_EN);
    }

private:
};

bool EditableChannelIDPropertyWithCallback::update(const odk::Property& value)
{
    const auto result = EditableChannelIDProperty::update(value);

    if (m_enable_callback)
    {
        ODK_ASSERT(m_parent);

        if (!m_parent)
        {
            return false;
        }

        auto all_output_channels = m_parent->getOutputChannels();

        for (auto& a_channel : all_output_channels)
        {
            if (m_local_id == a_channel->getLocalId())
            {
                auto channel_id = value.getChannelIDValue();

                const std::string new_text =
                    "Channel " + std::to_string(m_local_id) +
                    (( channel_id == std::numeric_limits<odk::ChannelID>::max()) ? " has no input channel" :
                    " now has input channel: " + std::to_string(channel_id));

                updateProperty<EditableStringProperty>(a_channel, KEY_DEBUG_TEXT, new_text);
                m_parent->markInputChannelChange(m_local_id);
            }
        }
    }

    return result;
}

OXY_REGISTER_PLUGIN1("ODK_PROPERTY_CALLBACK_EXAMPLE_PLUGIN", PLUGIN_MANIFEST, CallbackExamplePlugin);

